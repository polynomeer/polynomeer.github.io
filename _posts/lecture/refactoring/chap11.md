# 냄새 11. 기본형 집착 Primitive Obsession

- 애플리케이션이 다루고 있는 도메인에 필요한 기본 타입을 만들지 않고 프로그래밍 언어가 제공하는 기본 타입 을 사용하는 경우가 많다.
    - e.g. 전화번호, 좌표, 돈, 범위, 수량 등
- 기본형으로는 단위 (인치 vs 미터) 또는 표기법을 표현하기 어렵다.
- 관련 리팩토링 기술
    - “기본형을 객체로 바꾸기 (Replace Primitive with Object)”
    - “타입 코드를 서브클래스로 바꾸기 (Replace Type Code with Subclasses)” 
    - “조건부 로직을 다형성으로 바꾸기 (Replace Conditional with Polymorphism)”
    - “클래스 추출하기 (Extract Class)”
    - “매개변수 객체 만들기 (Introduce Parameter Object)”

## 리팩토링 30. 기본형을 객체로 바꾸기 Replace Primitive with Object

- 개발 초기에는 기본형 (숫자 또는 문자열)으로 표현한 데이터가 나중에는 해당 데이터와 관련있는 다양한 기능을 필요로 하는 경우가 발생한다.
    - e.g. 문자열로 표현하던 전화번호의 지역 코드가 필요하거나 다양한 포맷을 지원하는 경우.
    - e.g. 숫자로 표현하던 온도의 단위 (화씨, 섭씨)를 변환하는 경우.
- 기본형을 사용한 데이터를 감싸 줄 클래스를 만들면, 필요한 기능을 추가할 수 있다.

## 리팩토링 31. 타입 코드를 서브클래스로 바꾸기 Replace Type Code with Subclasses

- 비슷하지만 다른 것들을 표현해야 하는 경우, 문자열(String), 열거형 (enum), 숫자 (int) 등으로 표현하기도 한다.
    - e.g. 주문 타입, “일반 주문”, “빠른 주문”
    - e.g. 직원 타입, “엔지니어”, “매니저”, “세일즈”
- 타입을 서브클래스로 바꾸는 계기
    - 조건문을 다형성으로 표현할 수 있을 때, 서브클래스를 만들고 “조건부 로직을 다형 성으로 바꾸기”를 적용한다.
    - 특정 타입에만 유효한 필드가 있을 때, 서브클래스를 만들고 “필드 내리기”를 적용한다.

## 리팩토링 32. 조건부 로직을 다형성으로 바꾸기 Replace Conditional with Polymorphism

- 복잡한 조건식을 상속과 다형성을 사용해 코드를 보다 명확하게 분리할 수 있다.
- swich 문을 사용해서 타입에 따라 각기 다른 로직을 사용하는 코드.
- 기본 동작과 (타입에 따른) 특수한 기능이 섞여있는 경우에 상속 구조를 만들어서 기본 동작을 상위클래스에 두고 특수한 기능을 하위클래스로 옮겨서 각 타입에 따 른 “차이점”을 강조할 수 있다.
- 모든 조건문을 다형성으로 옮겨야 하는가? 단순한 조건문은 그대로 두어도 좋다. 오직 복잡한 조건문을 다형성을 활용해 좀 더 나은 코드로 만들 수 있는 경우에만 적용한다. (과용을 조심하자.)
